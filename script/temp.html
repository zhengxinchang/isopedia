<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Isopedia Splice View</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>

    <style>
        /* Add your custom styles here */
        /* set font size of all button */
        button {
            font-size: 10px;
            margin-left: 2px;
            margin-right: 2px;
        }
    </style>
</head>

<body style="margin: 0; height: 100vh;font-size: 14px; background-color: #F0F0F0;">
    <div id="app" style="display: flex; flex-direction: column; height: 100vh;">
        <div id='header'
            style="z-index:11;box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); color:#ba7027;  padding: 0 20px; display: flex; justify-content: space-between; align-items: center; height: 2.5vh;  position: relative;">

            <a href="https://github.com/zhengxinchang/isopedia" style="color:#ba7027;text-decoration: none;" target="_blank">
                <h4 style="margin: 0;">Isopedia Splice View</h4>
            </a>
            

            <div>ver. 1.0.0</div>

        </div>

        <div id="content" style="display: flex; height: 95vh;">

            <div id="left"
                style="z-index:10; box-shadow: 4px 0 6px rgba(0, 0, 0, 0.2);  width: 15%; background-color: #F0F0F0; padding: 3px;  overflow: auto;border: 0px solid black;border-right: none;">


                <expand-box name="Data Info" :expanded="true">
                    1. query information<br>
                    2. sample size<br>
                    3. isoform count<br>
                    4. reference annotation count<br>
                </expand-box>


                <expand-box name="Selected Isoform">

                </expand-box>

                <expand-box name="Selected Reference Transcript">

                </expand-box>


            </div>

            <div id="middle" style="z-index:9; width: 70%; background-color: lightblue; border: 0px solid black;">
                <!-- <svg id="main_svg" width="100%" height="100%"></svg> -->
                <!-- preserveAspectRatio="xMidYMid meet" -->
                <svg ref="svg" style="width: 100%; height: 100%; background-color: #FAFAFA;"></svg>
            </div>

            <div id="right"
                style="z-index:10; box-shadow: -4px 0 6px rgba(0, 0, 0, 0.2);  width: 15%; background-color: #F0F0F0; padding: 3px;  overflow: auto;border: 0px solid black;border-left: none;">

                <expand-box name="Zoom" :expanded="true">
                    <button @click="zoomIn">Zoom In</button>
                    <button @click="zoomOut">Zoom Out</button>
                    <button @click="resetView">Reset</button>
                </expand-box>


                <expand-box name ="Filter&Sort Reference Annotation">

                    <div>
                        <div>Genes to show</div>

                        <div>Only show query regionoverlapped transcripts</div>
                        <div v-for="transcript in transcripts" :key="transcript.id">
                        </div>
                    </div>

                    <div style="display: flex; justify-content: space-between;align-items: center;">
                        <button @click="filterIsopediaIndex">Apply</button>
                        <button @click="resetIsopediaIndex">Reset</button>
                    </div>

                </expand-box>

                <expand-box name="Filter&Sort Isopedia Index">

                    Lorem ipsum dolor sit amet consectetur, adipisicing elit. Aliquid inventore quibusdam eaque? Facere ipsum accusamus debitis delectus, ad aperiam quas laboriosam eaque sed accusantium nemo voluptatem id cupiditate, deserunt optio.

                    <div style="display: flex; justify-content: space-between;align-items: center;">
                        <button @click="filterIsopediaIndex">Apply</button>
                        <button @click="resetIsopediaIndex">Reset</button>
                    </div>
                    
                </expand-box>

                <expand-box name="Legend&Help">
                </expand-box>


            </div>

        </div>

        <div id='footer'
            style="z-index:12; box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.2); padding-left: 10px; display: flex; height:2.5vh;  justify-content: center; align-items: center; ">

            <div>
                <a href="https://fritzsedlazeck.github.io/"
                    style="text-decoration: none; color:blueviolet; padding-right: 5px;" target="_blank">@Sedlazeck
                    Lab, Baylor College of Medicine</a>
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;

        const app = createApp({
            data() {
                return {
                    meta: null,
                    annotation: null,
                    isoforms: null,

                    svg: null,
                    svgW: 0,
                    svgH: 0,
                    margin: { top: 40, right: 50, bottom: 40, left: 80 },
                    innerW: 0,
                    innerH: 0,

                    // X（共享）
                    x0: null,
                    xz: null,

                    // Bottom（连续 + band）
                    y0: null,      // 连续基准（行号 0..N）
                    yBand: null,   // 可视域 band（range 固定 [0, bodyH]）

                    // Top（连续 + band）
                    y0Ref: null,
                    yRefBand: null,

                    // 分组/轴
                    gRoot: null,
                    gTop: null,
                    gBottom: null,
                    gXAxis: null,
                    gYAxis: null,
                    gYAxisRef: null,
                    gContent: null,
                    gContentRef: null,

                    // 尺寸拆分
                    refH: 160,
                    bodyH: 0,

                    // 数据
                    sjData: [],
                    exonData: [],
                    readspanData: [],
                    ref_exons: [],
                    ref_cds: [],
                    ref_stop_codons: [],
                    ref_start_codons: [],
                    ref_utrs: [],
                    ref_tx_count: 0,
                    isoform_count: 0,

                    kShared: 1,
                    xShared: 0,
                };
            },

            methods: {
                /* ---------- 工具函数 ---------- */
                fetchJSON() {
                    return fetch("/aa.json")
                        .then(response => {
                            if (!response.ok) throw new Error("网络请求失败 " + response.status);
                            return response.json();
                        })
                        .then(data => {
                            this.meta = data.meta;
                            this.annotation = data.annotation;
                            this.isoforms = data.isoforms;
                            // console.log("loaded...", this.meta, this.annotation, this.isoforms);

                            this.isoforms.forEach(isofrom => {
                                console.log("isofrom", isofrom);
                                isofrom.pass = true;
                            });

                            this.annotation.forEach(ann => {
                                console.log("ann", ann);
                                // ann.transcripts is a dict

                                Object.keys(ann.transcripts).forEach(txId => {
                                    const tx = ann.transcripts[txId];
                                    tx.pass = true;
                                });
                            });
                        })
                        .catch(err => {
                            console.error("加载 JSON 出错:", err);
                            throw err; // 让外层 mounted() 能捕获
                        });
                },

                // transform -> visible rows
                visibleRowsFromTransform(t, baseY, panelH, maxRow) {
                    // console.log("baseY", baseY);
                    console.log("baseY domain", baseY.domain());
                    const yScaled = t.rescaleY(baseY);     // domain -> pixel（在当前变换下）
                    let start = Math.floor(yScaled.invert(0));          // 像素 0 对应的 domain
                    let end = Math.ceil(yScaled.invert(panelH));      // 像素 panelH 对应的 domain

                    // console.log("visibleRowsFromTransform", t, panelH, maxRow, start, end);
                    console.log("prev start,end", start, end);

                    start = Math.max(0, Math.min(maxRow - 1, start));
                    end = Math.max(1, Math.min(maxRow, end));

                    console.log("after start,end", start, end);

                    if (end <= start) end = Math.min(maxRow, start + 1);

                    // 转为 1..maxRow 的整数行号
                    // const rows = [];
                    // for (let r = start + 1; r <= end; r++) rows.push(r);
                    const rows = d3.range(start + 1, end + 1);
                    return rows;
                },

                visibleRowsFromBand(bandScale, panelH, maxRow, rate) {
                    const domain = bandScale.domain();
                    if (!domain.length) return domain;

                    // step 是相邻带的起点间距（含 padding），比 bandwidth 更合适用来估计“每屏能放几行”
                    let step = typeof bandScale.step === "function" ? bandScale.step() : bandScale.bandwidth();
                    const first = domain[0];                  // 当前顶部行（1-based）
                    step = step * (rate || 1);
                    console.log("step,first,panelH", step, first, panelH);
                    const visible = Math.max(1, Math.floor(panelH / step));
                    console.log("visible", visible);
                    const last = Math.min(maxRow, first + visible - 1);
                    console.log("last", last);
                    return d3.range(first, last + 1);
                },

                // 控制 y 轴刻度密度：按可视域长度与像素高度限流
                bandTicks(bandScale, panelH) {
                    const domain = bandScale.domain();
                    const maxTicks = Math.min(50, Math.max(3, Math.floor(panelH / 22)));
                    const step = Math.max(1, Math.ceil(domain.length / maxTicks));
                    const ticks = [];
                    for (let i = 0; i < domain.length; i += step) ticks.push(domain[i]);
                    return ticks;
                },

                // 绘制/更新 X 轴
                updateXAxis() {

                    const tId = d3.zoomIdentity.scale(this.kShared).translate(this.xShared, 0);
                    this.xz = tId.rescaleX(this.x0);

                    this.gXAxis.call(d3.axisTop(this.xz).ticks(Math.max(2, Math.floor(this.innerW / 80))));
                },

                // 刷新 Top：根据 yRefBand.domain 定位；域外隐藏
                renderTop() {
                    const ticks = this.bandTicks(this.yRefBand, this.refH);
                    this.gYAxisRef.call(d3.axisLeft(this.yRefBand).tickValues(ticks));
                    this.updateLines(this.gContentRef.selectAll("line.ref-exon"), this.xz, this.yRefBand);
                    this.updateLines(this.gContentRef.selectAll("line.ref-utrs"), this.xz, this.yRefBand);
                    this.updateLines(this.gContentRef.selectAll("line.ref-introns"), this.xz, this.yRefBand);
                    // this.updateLines(this.gContentRef.selectAll("rect.query-region"), this.xz, this.yRefBand);
                },

                // 刷新 Bottom：根据 yBand.domain 定位；域外隐藏
                renderBottom() {
                    const ticks = this.bandTicks(this.yBand, this.bodyH);
                    this.gYAxis.call(d3.axisLeft(this.yBand).tickValues(ticks));

                    this.updateLines(this.gContent.selectAll("line.splice"), this.xz, this.yBand);
                    this.updateLines(this.gContent.selectAll("line.exon"), this.xz, this.yBand);
                    this.updateLines(this.gContent.selectAll("line.readspan"), this.xz, this.yBand);

                },

                renderQueryRegion() {
                    this.gContent.selectAll("rect.query-region")
                        .attr("x", d => this.xz(d.x1))     // ✅ 用缩放后的 x
                        .attr("width", d => {
                            const w = this.xz(d.x2) - this.xz(d.x1);
                            return Math.max(1, w);           // ✅ 防止 0/负宽度
                        });

                    this.gContentRef.selectAll("rect.query-region")
                        .attr("x", d => this.xz(d.x1))     // ✅ 用缩放后的 x
                        .attr("width", d => {
                            const w = this.xz(d.x2) - this.xz(d.x1);
                            return Math.max(1, w);           // ✅ 防止 0/负宽度
                        });
                },

                updateLines(sel, xScale, yScale) {
                    // console.log(sel);
                    // sel.attr("x1", d => xScale(d.coord[0]))
                    //     .attr("x2", d => xScale(d.coord[1]))

                    const tId = d3.zoomIdentity.scale(this.kShared).translate(this.xShared, 0);
                    this.xz = tId.rescaleX(this.x0);

                    sel
                        .attr("x1", d => this.xz(d.coord[0]))
                        .attr("x2", d => this.xz(d.coord[1]))
                        // .attr("x1", d => d.coord[0])
                        // .attr("x2", d => d.coord[1])
                        .each((d, i, nodes) => {

                            // if (i < 5) {
                            //     console.log("updating line", d.coord, i);
                            // }


                            const y = yScale(d.row);

                            const el = d3.select(nodes[i]);
                            if (y == null) {
                                el.style("display", "none").attr("y1", null).attr("y2", null);
                            } else {
                                const ym = y + yScale.bandwidth() / 2;
                                el.style("display", null).attr("y1", ym).attr("y2", ym);
                            }
                        });
                },

                bindLines(sel, data, cls, color, width) {
                    sel.data(data)
                        .join("line")
                        .attr("class", cls)
                        .attr("stroke", color)
                        .attr("stroke-width", width)
                        .attr("vector-effect", "non-scaling-stroke");
                },

                zoomIn() {
                    const newK = this.kShared * 1.2;
                    if (newK > 150) return;
                    this.kShared = newK;
                    this.xShared = this.xShared - (this.innerW / 2) * (newK - this.kShared) / newK;
                    const tId = d3.zoomIdentity.scale(this.kShared).translate(this.xShared, 0);

                    // 顶部
                    console.log("y0Ref", this.y0Ref);
                    console.log("y0", this.y0);

                    startDomainRef = this.yRefBand.domain().map(d => d);
                    startDomainData = this.yBand.domain().map(d => d);

                    const rowsTop = this.visibleRowsFromBand(this.yRefBand, this.refH, this.ref_tx_count, 1.2);

                    // console.log("rowsTop", rowsTop);

                    this.yRefBand.domain(rowsTop);
                    this.renderTop();
                    // 底部
                    const rowsBottom = this.visibleRowsFromBand(this.yBand, this.bodyH, this.isoform_count, 1.2);
                    console.log("rowsBottom", rowsBottom);
                    this.yBand.domain(rowsBottom);
                    this.renderBottom();

                    // X 轴
                    this.xz = tId.rescaleX(this.x0);
                    this.updateXAxis();


                    this.renderQueryRegion();
                },

                zoomOut() {

                    const newK = this.kShared / 1.2;
                    if (newK < 1) return;
                    this.kShared = newK;
                    this.xShared = this.xShared - (this.innerW / 2) * (newK - this.kShared) / newK;
                    const tId = d3.zoomIdentity.scale(this.kShared).translate(this.xShared, 0);

                    // 顶部
                    const rowsTop = this.visibleRowsFromBand(this.yRefBand, this.refH, this.ref_tx_count, 1 / 1.2);
                    this.yRefBand.domain(rowsTop);
                    this.renderTop();
                    // 底部
                    const rowsBottom = this.visibleRowsFromBand(this.yBand, this.bodyH, this.isoform_count, 1 / 1.2);
                    this.yBand.domain(rowsBottom);
                    this.renderBottom();

                    // X 轴
                    this.xz = tId.rescaleX(this.x0);
                    this.updateXAxis();

                    this.renderQueryRegion();
                },

                resetView() {

                    const xdomain = [this.meta.left_most, this.meta.right_most];

                    // X（共享）
                    this.x0 = d3.scaleLinear().domain(xdomain).range([0, this.innerW]);
                    this.xz = this.x0.copy();

                    // Bottom Y 连续基准（domain 0..N，range 0..bodyH）
                    this.y0 = d3.scaleLinear().domain([0, this.isoform_count]).range([0, this.bodyH]);
                    // Bottom Y band（range 固定 0..bodyH，domain 初始化为全部行 1..N）
                    this.yBand = d3.scaleBand().domain(d3.range(1, this.isoform_count + 1)).range([0, this.bodyH]).padding(0.3);

                    // Top Y 连续基准
                    this.y0Ref = d3.scaleLinear().domain([0, this.ref_tx_count]).range([0, this.refH]);
                    // Top Y band（range 固定 0..refH，domain 初始化为全部行 1..M）
                    this.yRefBand = d3.scaleBand().domain(d3.range(1, this.ref_tx_count + 1)).range([0, this.refH]).padding(0.3);


                    // 让两个面板都以 identity 计算可视域
                    this.kShared = 1;
                    this.xShared = 0;
                    this.xz = this.x0.copy();
                    const tId = d3.zoomIdentity.scale(this.kShared).translate(this.xShared, 0);

                    this.renderQueryRegion();

                    // 初始一次完整渲染（等价于 identity 变换）
                    this.updateXAxis();

                    // 顶部


                    const rowsTop = this.visibleRowsFromBand(this.yRefBand, this.refH, this.ref_tx_count, 1);

                    this.yRefBand.domain(rowsTop);
                    this.renderTop();
                    // 底部
                    const rowsBottom = this.visibleRowsFromBand(this.yBand, this.bodyH, this.isoform_count, 1);
                    this.yBand.domain(rowsBottom);
                    this.renderBottom();
                },


                enableDrag() {
                    let isDragging = false;
                    let startX = 0;
                    let startY = 0;
                    let startSharedX = 0;
                    let startDomainRef = [];
                    let startDomainData = [];

                    // 鼠标按下
                    this.svg.on("mousedown", (event) => {
                        isDragging = true;
                        startX = event.clientX;
                        startY = event.clientY;
                        startSharedX = this.xShared;
                        startDomainRef = this.yRefBand.domain().map(d => d);
                        startDomainData = this.yBand.domain().map(d => d);
                    });

                    // 鼠标移动
                    d3.select(window).on("mousemove", (event) => {
                        if (!isDragging) return;

                        const dx = event.clientX - startX;
                        const dy = event.clientY - startY;

                        // ---- 水平拖动：更新 xShared，保持上下同步 ----
                        this.xShared = startSharedX + dx;
                        this.xz = this.x0.copy()
                            .range([0, this.innerW].map(d => this.kShared * d + this.xShared));

                        this.updateXAxis();
                        this.renderQueryRegion();
                        this.renderTop();
                        this.renderBottom();


                        let gNode = event.target.closest("g");

                        if (!gNode) return;

                        // ---- 垂直拖动：分别移动顶部和底部 ----
                        if (dy !== 0) {
                            // Top
                            if (gNode.getAttribute("class") === "content-ref") {

                                let shiftedRef = startDomainRef.map(r => r - Math.round(dy / this.yRefBand.bandwidth()));

                                if (startDomainRef[0] == 1 && shiftedRef[0] <= 1) return;

                                if (startDomainRef[startDomainRef.length - 1] == this.ref_tx_count && shiftedRef[shiftedRef.length - 1] >= this.ref_tx_count) return;

                                shiftedRef = shiftedRef.filter(r => r > 0 && r <= this.ref_tx_count);

                                if (shiftedRef.length > 0) {
                                    this.yRefBand.domain(shiftedRef);
                                    this.renderTop();
                                }
                            }

                            // Bottom
                            if (gNode.getAttribute("class") === "content") {

                                let shiftedData = startDomainData.map(r => r - Math.round(dy / this.yBand.bandwidth()));

                                // console.log("startDomainData[0]", startDomainData[0]);
                                // console.log("startDomainData[-1]", startDomainData[startDomainData.length - 1]);
                                // console.log("startDomainData", startDomainData);
                                // console.log("shiftedData", shiftedData);


                                if (startDomainData[0] == 1 && shiftedData[0] <= 1) return;
                                if (startDomainData[startDomainData.length - 1] == this.isoform_count && shiftedData[shiftedData.length - 1] >= this.isoform_count) return;

                                shiftedData = shiftedData.filter(r => r > 0 && r <= this.isoform_count);
                                if (shiftedData.length > 0) {
                                    this.yBand.domain(shiftedData);
                                    this.renderBottom();
                                }
                            }
                        }
                    });

                    // 鼠标松开
                    d3.select(window).on("mouseup", () => {
                        isDragging = false;
                    });
                },




                prepare() {
                    // 1) 预处理 reference
                    this.ref_tx_count = 0;
                    this.ref_exons = [];
                    this.ref_cds = [];
                    this.ref_stop_codons = [];
                    this.ref_start_codons = [];
                    this.ref_utrs = [];
                    this.ref_introns = [];

                    this.annotation.forEach(gene => {
                        Object.values(gene.transcripts).forEach(tx => {
                            this.ref_tx_count += 1;
                            let intron = [];
                            tx.elements.forEach(el => {
                                const push = (arr) => arr.push({
                                    feature: el.feature,
                                    row: this.ref_tx_count,
                                    coord: [el.start, el.end],
                                    tx_id: el.transcript_id,
                                    gene_id: el.gene_id
                                });
                                if (el.feature === 'exon') {
                                    push(this.ref_exons)
                                    intron.push(el.start);
                                    intron.push(el.end);
                                }
                                else if (el.feature === 'CDS') push(this.ref_cds);
                                else if (el.feature === 'stop_codon') push(this.ref_stop_codons);
                                else if (el.feature === 'start_codon') push(this.ref_start_codons);
                                else if (el.feature === 'UTR') push(this.ref_utrs);
                            });

                            // remove the first and last element (not intron)
                            intron = intron.slice(1, -1);
                            for (let i = 0; i < intron.length; i += 2) {
                                this.ref_introns.push({ coord: [intron[i], intron[i + 1]], row: this.ref_tx_count });
                            }
                        });
                    });


                    // 2) 预处理 bottom（isoforms）
                    this.sjData = [];
                    this.exonData = [];
                    this.readspanData = [];
                    this.isoforms.forEach((iso, i) => { iso._row = i + 1; });

                    this.isoforms.forEach(iso => {
                        (iso.splice_junction || []).forEach(sj => {
                            this.sjData.push({ coord: sj, row: iso._row });
                        });
                        const splice_sites = (iso.splice_sites || []).slice();
                        splice_sites.unshift(iso.start_pos_right);
                        splice_sites.push(iso.end_pos_left);
                        splice_sites.forEach((pos, i) => {
                            if (i % 2 === 0 && splice_sites[i + 1] != null) {
                                this.exonData.push({ coord: [pos, splice_sites[i + 1]], row: iso._row });
                            }
                        });
                        this.readspanData.push({ coord: [iso.start_pos_left, iso.start_pos_right], row: iso._row });
                        this.readspanData.push({ coord: [iso.end_pos_left, iso.end_pos_right], row: iso._row });
                    });

                    // 3) 尺寸
                    const { width, height } = this.svg.node().getBoundingClientRect();
                    this.svgW = width;
                    this.svgH = height;
                    this.innerW = Math.max(10, width - this.margin.left - this.margin.right);
                    this.innerH = Math.max(10, height - this.margin.top - this.margin.bottom);
                    this.bodyH = Math.max(10, this.innerH - this.refH);

                    // 4) 尺度
                    this.isoform_count = this.isoforms.length;
                    const xdomain = [this.meta.left_most, this.meta.right_most];

                    // X（共享）
                    this.x0 = d3.scaleLinear().domain(xdomain).range([0, this.innerW]);
                    this.xz = this.x0.copy();

                    // Bottom Y 连续基准（domain 0..N，range 0..bodyH）
                    this.y0 = d3.scaleLinear().domain([0, this.isoform_count]).range([0, this.bodyH]);
                    // Bottom Y band（range 固定 0..bodyH，domain 初始化为全部行 1..N）
                    this.yBand = d3.scaleBand().domain(d3.range(1, this.isoform_count + 1)).range([0, this.bodyH]).padding(0.3);

                    // Top Y 连续基准
                    this.y0Ref = d3.scaleLinear().domain([0, this.ref_tx_count]).range([0, this.refH]);
                    // Top Y band（range 固定 0..refH，domain 初始化为全部行 1..M）
                    this.yRefBand = d3.scaleBand().domain(d3.range(1, this.ref_tx_count + 1)).range([0, this.refH]).padding(0.3);

                    // 5) SVG & 分组
                    this.svg.attr("viewBox", `0 0 ${width} ${height}`).selectAll("*").remove();

                    this.gRoot = this.svg.append("g")
                        .attr("transform", `translate(${this.margin.left},${this.margin.top})`);

                    this.gTop = this.gRoot.append("g")
                        .attr("class", "top-ref")
                        .attr("transform", "translate(0,0)");

                    this.gBottom = this.gRoot.append("g")
                        .attr("class", "bottom-body")
                        .attr("transform", `translate(0,${this.refH})`);

                    // 只裁内容，不裁轴
                    const defs = this.svg.append("defs");
                    defs.append("clipPath").attr("id", "clipTop")
                        .append("rect").attr("x", 0).attr("y", 0)
                        .attr("width", this.innerW).attr("height", this.refH);
                    defs.append("clipPath").attr("id", "clipBottom")
                        .append("rect").attr("x", 0).attr("y", 0)
                        .attr("width", this.innerW).attr("height", this.bodyH);

                    // 轴组
                    this.gXAxis = this.gTop.append("g")
                        .attr("class", "x-axis")
                        .attr("transform", "translate(0,0)")
                        .call(d3.axisTop(this.xz).ticks(10));

                    this.gYAxisRef = this.gTop.append("g").attr("class", "y-axis-ref");
                    this.gYAxis = this.gBottom.append("g").attr("class", "y-axis");

                    // 内容组（clip）
                    this.gContentRef = this.gTop.append("g").attr("class", "content-ref")
                        .attr("clip-path", "url(#clipTop)");

                    this.gContentRef.append("rect")
                        .attr("class", "bg-ref")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", this.innerW)
                        .attr("height", this.refH)
                        // .style("fill", "transparent")
                        .attr("fill", "lightblue")
                        .attr("fill-opacity", 0.1)   // 调整透明度
                        .style("pointer-events", "all");   // 透明但能接收事件


                    this.gContent = this.gBottom.append("g").attr("class", "content")
                        .attr("clip-path", "url(#clipBottom)");

                    this.gContent.append("rect")
                        .attr("class", "bg-content")
                        .attr("x", 0)
                        .attr("y", 0)
                        .attr("width", this.innerW)
                        .attr("height", this.bodyH)
                        .attr("fill", "lightpink")
                        .attr("fill-opacity", 0.1)   // 调整透明度
                        .style("pointer-events", "all");

                    // y labels

                    // 给顶部 Y 轴加 label
                    this.gYAxisRef.append("text")
                        .attr("class", "y-label-ref")
                        .attr("transform", "rotate(-90)")       // 旋转 90 度
                        .attr("y", -50)                         // 调整位置（负数往左）
                        .attr("x", -this.refH / 2)              // 垂直居中
                        .attr("dy", "1em")
                        .style("text-anchor", "middle")
                        .style("fill", "black")
                        .text("Reference Annotation");

                    // 给底部 Y 轴加 label
                    this.gYAxis.append("text")
                        .attr("class", "y-label-data")
                        .attr("transform", "rotate(-90)")
                        .attr("y", -50)
                        .attr("x", -this.bodyH / 2)             // 垂直居中
                        .attr("dy", "1em")
                        .style("text-anchor", "middle")
                        .style("fill", "black")
                        .text("Isopedia Index");

                    this.gXAxis.append("text")
                        .attr("class", "x-label")
                        .attr("x", this.innerW / 2)
                        .attr("y", -25)
                        .style("text-anchor", "middle")
                        .style("fill", "black")
                        .text("Genomic Position");


                },
                drawQueryRegion() {

                    const iso0 = this.isoforms[0];
                    const x1 = +iso0.pos1;
                    const x2 = +iso0.pos2;
                    const xLeft = Math.min(x1, x2);
                    const xRight = Math.max(x1, x2);
                    this.gContent
                        .selectAll("rect.query-region")
                        .data([{ x1: xLeft, x2: xRight }])
                        .join("rect")
                        .attr("class", "query-region")
                        .attr("x", d => this.xz(d.x1))
                        .attr("y", 0)
                        .attr("width", d => {
                            const w = this.xz(d.x2) - this.xz(d.x1);
                            return Math.max(1, w);
                        })
                        .attr("height", this.bodyH)
                        .attr("fill", "purple")
                        .attr("fill-opacity", 0.42)
                        .style("pointer-events", "none");

                    this.gContentRef
                        .selectAll("rect.query-region")
                        .data([{ x1: xLeft, x2: xRight }])
                        .join("rect")
                        .attr("class", "query-region")
                        .attr("x", d => this.xz(d.x1))
                        .attr("y", 0)
                        .attr("width", d => {
                            const w = this.xz(d.x2) - this.xz(d.x1);
                            return Math.max(1, w);
                        })
                        .attr("height", this.refH)
                        .attr("fill", "purple")
                        .attr("fill-opacity", 0.42)
                        .style("pointer-events", "none");
                },

                draw() {

                    // 取一个 isoform 的左右边界（你可以按需求换成 right/left 的组合）


                    this.drawQueryRegion();

                    this.bindLines(this.gContent.selectAll("line.splice"), this.sjData, "splice", "pink", 0.8);
                    this.bindLines(this.gContent.selectAll("line.exon"), this.exonData, "exon", "black", 4);
                    this.bindLines(this.gContent.selectAll("line.readspan"), this.readspanData, "readspan", "blue", 4);
                    this.bindLines(this.gContentRef.selectAll("line.ref-introns"), this.ref_introns, "ref-introns", "green", 0.8);
                    this.bindLines(this.gContentRef.selectAll("line.ref-exon"), this.ref_exons, "ref-exon", "black", 4);
                    this.bindLines(this.gContentRef.selectAll("line.ref-utrs"), this.ref_utrs, "ref-utrs", "orange", 4);





                    // 让两个面板都以 identity 计算可视域
                    const tId = d3.zoomIdentity.scale(this.kShared).translate(this.xShared, 0);

                    // 初始一次完整渲染（等价于 identity 变换）
                    this.updateXAxis();

                    // 顶部


                    const rowsTop = this.visibleRowsFromBand(this.yRefBand, this.refH, this.ref_tx_count, 1);

                    this.yRefBand.domain(rowsTop);
                    this.renderTop();
                    // 底部
                    const rowsBottom = this.visibleRowsFromBand(this.yBand, this.bodyH, this.isoform_count, 1);
                    this.yBand.domain(rowsBottom);
                    this.renderBottom();
                },

            },

            mounted() {
                this.svg = d3.select(this.$refs.svg);
                this.fetchJSON().then(() => {
                    this.prepare();
                    this.draw();
                    this.enableDrag();
                });
            }
        });






        // 注册组件
        app.component('expand-box', {

            data() {
                return {
                    curr_expanded: null,
                };
            },
            props: {
                'name': {
                    type: String,
                    required: true
                },
                'expanded': {
                    type: Boolean,
                    default: true,
                }
            },
            created() {
                this.curr_expanded = this.expanded;
            },
            template: `
                <div style="margin-top:1px;">
                    <div @click="toggle" style="box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2); padding-left:2px;padding-right:2px; background-color: lightgray; display: flex; justify-content: space-between; align-items: center; cursor: pointer; user-select: none;"> {{ name }} <span v-if="curr_expanded">[&minus;]</span><span v-else>[+]</span></div>
                    <div v-if="curr_expanded" style="margin-left: 10px; margin-top: 5px;">
                        <slot></slot>
                    </div>
                </div>
            `,
            methods: {
                toggle() {
                    this.curr_expanded = !this.curr_expanded;
                }
            }
        });

        app.mount('#app');

    </script>
</body>

</html>